{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, Component, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { Observable, Subject } from 'rxjs';\nimport { debounceTime, filter, takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [\"tape\"];\n\nconst _c1 = function (a0) {\n  return {\n    \"ngx-marquee-pause-on-hover\": a0\n  };\n};\n\nconst _c2 = [\"*\"];\nvar IntersectionStatus = /*#__PURE__*/(() => {\n  (function (IntersectionStatus) {\n    IntersectionStatus[\"Visible\"] = \"Visible\";\n    IntersectionStatus[\"Pending\"] = \"Pending\";\n    IntersectionStatus[\"NotVisible\"] = \"NotVisible\";\n  })(IntersectionStatus || (IntersectionStatus = {}));\n\n  return IntersectionStatus;\n})();\n\nconst fromIntersectionObserver = (element, config, debounce = 0) => new Observable(subscriber => {\n  const subject$ = new Subject();\n  const intersectionObserver = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      subject$.next({\n        entry,\n        observer\n      });\n    });\n  }, config);\n  subject$.subscribe(() => {\n    subscriber.next(IntersectionStatus.Pending);\n  });\n  subject$.pipe(debounceTime(debounce), filter(Boolean)).subscribe(({\n    entry,\n    observer\n  }) => __awaiter(void 0, void 0, void 0, function* () {\n    const isEntryVisible = yield isVisible(entry.target);\n\n    if (isEntryVisible) {\n      subscriber.next(IntersectionStatus.Visible);\n    } else {\n      subscriber.next(IntersectionStatus.NotVisible);\n    }\n  }));\n  intersectionObserver.observe(element);\n  return {\n    unsubscribe() {\n      intersectionObserver.disconnect();\n      subject$.unsubscribe();\n    }\n\n  };\n});\n\nfunction isVisible(element) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        resolve(entry.isIntersecting);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  });\n}\n\nlet IntersectionObserverDirective = /*#__PURE__*/(() => {\n  class IntersectionObserverDirective {\n    constructor(_element) {\n      this._element = _element;\n      this.intersectionDebounce = 0;\n      this.intersectionRootMargin = '0px';\n      this.visibilityChange = new EventEmitter();\n      this._destroy$ = new Subject();\n    }\n\n    ngOnInit() {\n      const element = this._element.nativeElement;\n      const config = {\n        root: this.intersectionRoot,\n        rootMargin: this.intersectionRootMargin,\n        threshold: this.intersectionThreshold\n      };\n      fromIntersectionObserver(element, config, this.intersectionDebounce).pipe(takeUntil(this._destroy$)).subscribe(status => {\n        this.visibilityChange.emit(status);\n      });\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next(void 0);\n    }\n\n  }\n\n  IntersectionObserverDirective.ɵfac = function IntersectionObserverDirective_Factory(t) {\n    return new (t || IntersectionObserverDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IntersectionObserverDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IntersectionObserverDirective,\n    selectors: [[\"\", \"intersectionObserver\", \"\"]],\n    inputs: {\n      intersectionDebounce: \"intersectionDebounce\",\n      intersectionRootMargin: \"intersectionRootMargin\",\n      intersectionRoot: \"intersectionRoot\",\n      intersectionThreshold: \"intersectionThreshold\"\n    },\n    outputs: {\n      visibilityChange: \"visibilityChange\"\n    }\n  });\n  return IntersectionObserverDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar MarqueeState = /*#__PURE__*/(() => {\n  (function (MarqueeState) {\n    MarqueeState[\"Running\"] = \"running\";\n    MarqueeState[\"Paused\"] = \"paused\";\n    MarqueeState[\"Stopped\"] = \"stopped\";\n  })(MarqueeState || (MarqueeState = {}));\n\n  return MarqueeState;\n})();\nvar MarqueeDirection = /*#__PURE__*/(() => {\n  (function (MarqueeDirection) {\n    MarqueeDirection[\"Left\"] = \"left\";\n    MarqueeDirection[\"Right\"] = \"right\";\n    MarqueeDirection[\"Alternate\"] = \"alternate\";\n  })(MarqueeDirection || (MarqueeDirection = {}));\n\n  return MarqueeDirection;\n})();\nvar MarqueeAnimation = /*#__PURE__*/(() => {\n  (function (MarqueeAnimation) {\n    MarqueeAnimation[\"Default\"] = \"default\";\n    MarqueeAnimation[\"SlideInUp\"] = \"slideInUp\";\n    MarqueeAnimation[\"SlideInDown\"] = \"slideInDown\";\n  })(MarqueeAnimation || (MarqueeAnimation = {}));\n\n  return MarqueeAnimation;\n})();\nlet NgxMarqueeComponent = /*#__PURE__*/(() => {\n  class NgxMarqueeComponent {\n    constructor(_renderer) {\n      this._renderer = _renderer;\n      this._outerFlags = [false, false];\n      this.debounce = 0;\n      this.root = undefined;\n      this.rootMargin = '0px';\n      this.threshold = 0;\n      this.duration = '20s';\n      this.animation = MarqueeAnimation.Default;\n      this.pauseOnHover = false;\n      this.pendingUpdates = false;\n      this.pendingUpdatesChange = new EventEmitter();\n      this.playStateChange = new EventEmitter();\n\n      if (typeof this.taskOnUpdateContent !== 'function') {\n        this.taskOnUpdateContent = () => {};\n      }\n\n      if (typeof this.taskOnUpdateDuration !== 'function') {\n        this.taskOnUpdateDuration = () => {\n          return this.duration;\n        };\n      }\n    }\n\n    ngAfterViewInit() {\n      this._elementMarquee = this._renderer.selectRootElement(this.tape, true).nativeElement;\n\n      this._resetMarquee();\n    }\n\n    playPause() {\n      if (this._dataPlayState === null || this._dataPlayState === MarqueeState.Running) {\n        this._pauseElement();\n      } else {\n        this._playElement();\n      }\n    }\n\n    stop() {\n      this._resetAnimation();\n\n      this._stopElement();\n    }\n\n    restart() {\n      this._resetAnimation();\n\n      this._playElement();\n    }\n\n    onVisibilityChanged(status, control) {\n      if (status !== IntersectionStatus.Pending) {\n        if (status === IntersectionStatus.Visible) {\n          this._outerFlags[control] = true;\n        } else if (status === IntersectionStatus.NotVisible) {\n          this._outerFlags[control] = false;\n        }\n\n        if (this.pendingUpdates) {\n          if ((this.direction === undefined || this.direction === MarqueeDirection.Left) && this._outerFlags[0] === true && this._outerFlags[1] === false) {\n            this._execProcedure();\n          } else if (this.direction === MarqueeDirection.Right && this._outerFlags[0] === false && this._outerFlags[1] === true) {\n            this._execProcedure();\n          }\n        }\n      }\n    }\n\n    _execProcedure() {\n      this.taskOnUpdateContent();\n\n      this._resetMarquee();\n\n      this._setPendingUpdates(false);\n    }\n\n    _setDataPlayState(state) {\n      this._dataPlayState = state;\n      this.playStateChange.emit(this._dataPlayState);\n    }\n\n    _setPendingUpdates(state) {\n      this.pendingUpdates = state;\n      this.pendingUpdatesChange.emit(this.pendingUpdates);\n    }\n\n    _resetMarquee() {\n      this.stop();\n\n      this._calculateDuration();\n\n      this._playElement();\n    }\n\n    _calculateDuration() {\n      this.duration = this.taskOnUpdateDuration();\n    }\n\n    _playElement() {\n      this._setAnimationState('running', true);\n\n      this._setDataAttrState('running');\n\n      this._setDataPlayState(MarqueeState.Running);\n    }\n\n    _pauseElement() {\n      this._setAnimationState('paused');\n\n      this._setDataAttrState('paused');\n\n      this._setDataPlayState(MarqueeState.Paused);\n    }\n\n    _stopElement() {\n      this._setAnimationState('paused');\n\n      this._setDataAttrState('stopped');\n\n      this._setDataPlayState(MarqueeState.Stopped);\n\n      this._setPendingUpdates(false);\n    }\n\n    _setAnimationState(state = '', fix = false) {\n      this._renderer.setStyle(this._elementMarquee, 'animation-play-state', state);\n\n      if (fix) {\n        this._fixAnimationState();\n      }\n    }\n\n    _resetAnimation() {\n      this._renderer.setStyle(this._elementMarquee, 'animation', 'none');\n\n      let fix = this._elementMarquee.offsetWidth;\n      fix = fix;\n\n      this._renderer.setStyle(this._elementMarquee, 'animation', `${this.duration} linear infinite`);\n\n      this._renderer.setStyle(this._elementMarquee, '-webkit-animation', `${this.duration} linear infinite`);\n\n      switch (this.direction) {\n        case 'alternate':\n          this._renderer.setStyle(this._elementMarquee, 'animation-direction', 'alternate');\n\n          break;\n\n        default:\n          this._renderer.setStyle(this._elementMarquee, 'animation-direction', 'normal');\n\n          break;\n      }\n\n      if (this.direction !== MarqueeDirection.Alternate) {\n        if (this.direction === undefined || this.direction === MarqueeDirection.Left) {\n          if (this.animation === MarqueeAnimation.SlideInUp) {\n            this._renderer.setStyle(this._elementMarquee, 'animation-name', 'slide-in-up');\n          } else if (this.animation === MarqueeAnimation.SlideInDown) {\n            this._renderer.setStyle(this._elementMarquee, 'animation-name', 'slide-in-down');\n          } else {\n            this._renderer.setStyle(this._elementMarquee, 'animation-name', 'movement-smooth');\n          }\n        } else if (this.direction === MarqueeDirection.Right) {\n          if (this.animation === MarqueeAnimation.SlideInUp) {\n            this._renderer.setStyle(this._elementMarquee, 'animation-name', 'slide-in-up-right');\n          } else if (this.animation === MarqueeAnimation.SlideInDown) {\n            this._renderer.setStyle(this._elementMarquee, 'animation-name', 'slide-in-down-right');\n          } else {\n            this._renderer.setStyle(this._elementMarquee, 'animation-direction', 'reverse');\n\n            this._renderer.setStyle(this._elementMarquee, 'animation-name', 'movement-smooth');\n          }\n        }\n      } else {\n        this._renderer.setStyle(this._elementMarquee, 'animation-name', 'movement-smooth');\n      }\n    }\n\n    _setDataAttrState(state = '') {\n      this._renderer.setAttribute(this._elementMarquee, 'data-play-state', state);\n    }\n\n    _fixAnimationState() {\n      this._renderer.removeStyle(this._elementMarquee, 'animation-play-state');\n    }\n\n  }\n\n  NgxMarqueeComponent.ɵfac = function NgxMarqueeComponent_Factory(t) {\n    return new (t || NgxMarqueeComponent)(i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  NgxMarqueeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMarqueeComponent,\n    selectors: [[\"ngx-marquee\"]],\n    viewQuery: function NgxMarqueeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tape = _t.first);\n      }\n    },\n    inputs: {\n      direction: \"direction\",\n      duration: \"duration\",\n      pauseOnHover: \"pauseOnHover\",\n      animation: \"animation\",\n      taskOnUpdateContent: \"taskOnUpdateContent\",\n      taskOnUpdateDuration: \"taskOnUpdateDuration\",\n      pendingUpdates: \"pendingUpdates\"\n    },\n    outputs: {\n      pendingUpdatesChange: \"pendingUpdatesChange\",\n      playStateChange: \"playStateChange\"\n    },\n    ngContentSelectors: _c2,\n    decls: 9,\n    vars: 11,\n    consts: [[1, \"ngx-marquee\", 3, \"ngClass\"], [\"tape\", \"\"], [\"intersectionObserver\", \"\", 1, \"ticker-control\", \"ticker-start\", 3, \"intersectionRoot\", \"intersectionRootMargin\", \"intersectionThreshold\", \"intersectionDebounce\", \"visibilityChange\"], [1, \"tickers\"], [\"intersectionObserver\", \"\", 1, \"ticker-control\", \"ticker-end\", 3, \"intersectionRoot\", \"intersectionRootMargin\", \"intersectionThreshold\", \"intersectionDebounce\", \"visibilityChange\"]],\n    template: function NgxMarqueeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"span\", null, 1);\n        i0.ɵɵelementStart(3, \"span\", 2);\n        i0.ɵɵlistener(\"visibilityChange\", function NgxMarqueeComponent_Template_span_visibilityChange_3_listener($event) {\n          return ctx.onVisibilityChanged($event, 0);\n        });\n        i0.ɵɵtext(4, \"L\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"span\", 3);\n        i0.ɵɵprojection(6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"span\", 4);\n        i0.ɵɵlistener(\"visibilityChange\", function NgxMarqueeComponent_Template_span_visibilityChange_7_listener($event) {\n          return ctx.onVisibilityChanged($event, 1);\n        });\n        i0.ɵɵtext(8, \"R\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(9, _c1, ctx.pauseOnHover));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"intersectionRoot\", ctx.root)(\"intersectionRootMargin\", ctx.rootMargin)(\"intersectionThreshold\", ctx.threshold)(\"intersectionDebounce\", ctx.debounce);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"intersectionRoot\", ctx.root)(\"intersectionRootMargin\", ctx.rootMargin)(\"intersectionThreshold\", ctx.threshold)(\"intersectionDebounce\", ctx.debounce);\n      }\n    },\n    directives: [i1.NgClass, IntersectionObserverDirective],\n    styles: [\".ngx-marquee[_ngcontent-%COMP%]{overflow:hidden;text-align:left}.ngx-marquee.ngx-marquee-pause-on-hover[_ngcontent-%COMP%]:hover > span[_ngcontent-%COMP%]{animation-play-state:paused}.ngx-marquee[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{content:attr(data-marquee);display:inline-block;position:relative;white-space:nowrap;animation:linear infinite}.ngx-marquee[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{animation-duration:20s}.ngx-marquee[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{animation-direction:normal}.ngx-marquee[_ngcontent-%COMP%]   span.ticker-control[_ngcontent-%COMP%]{display:inline-block;width:20px;text-align:center;color:transparent;background-color:transparent}.ngx-marquee.ngx-marquee-direction-left[_ngcontent-%COMP%] > span[_ngcontent-%COMP%], .ngx-marquee.ngx-marquee-direction-normal[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{animation-direction:normal}@keyframes movement-smooth{0%{transform:translate(0);left:100%}to{transform:translate(-100%);left:0%}}@keyframes slide-in-up{0%{transform:translateY(100%);left:0%}10%{transform:translateY(0);left:0%}16%{transform:translate(0)}to{transform:translate(-100%);left:0%}}@keyframes slide-in-down{0%{transform:translateY(-100%);left:0%}10%{transform:translateY(0);left:0%}16%{transform:translate(0)}to{transform:translate(-100%);left:0%}}@keyframes slide-in-up-right{0%{transform:translate(-100%,100%);right:-100%}10%{transform:translate(-100%);right:-100%}16%{transform:translate(-100%)}to{transform:translate(0);right:-100%}}@keyframes slide-in-down-right{0%{transform:translate(-100%,-100%);right:-100%}10%{transform:translate(-100%);right:-100%}16%{transform:translate(-100%)}to{transform:translate(0);right:-100%}}\"],\n    changeDetection: 0\n  });\n  return NgxMarqueeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxMarqueeModule = /*#__PURE__*/(() => {\n  class NgxMarqueeModule {}\n\n  NgxMarqueeModule.ɵfac = function NgxMarqueeModule_Factory(t) {\n    return new (t || NgxMarqueeModule)();\n  };\n\n  NgxMarqueeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxMarqueeModule\n  });\n  NgxMarqueeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NgxMarqueeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-marquee\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { MarqueeAnimation, MarqueeDirection, MarqueeState, NgxMarqueeComponent, NgxMarqueeModule }; //# sourceMappingURL=ngx-marquee.mjs.map","map":null,"metadata":{},"sourceType":"module"}